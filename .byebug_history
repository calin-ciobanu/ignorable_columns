exit
@attributes
attribute_names
@attributes.map { |a| puts a.type }
wtf?
c@attributes.to_hash
c
where
self.class.attributes
self.class.attribute
self.class._default_attributes
_default_attributes
wtf?
@attributes.to_hash
c
wtf?
show-source model.attributes
c
cd super
show-source super
show-source attributes
show-source 'attributes'
show-source :attributes
show-source(:attributes)
help
source-code(:attributes)
source-code attributes
cd attributes
cd ..
ls
cd self
help
cd attributes
ls attributes
ls super
exit
s.count
s.size
s = 'abc'
Kaminari.paginate_array('abc')
'abc'.last
exit
EXIT
exit
DataSource.method(:attribute_types).source_location
h.reject { |x| x == :a }
h.reject { |x| puts x }
h = {a: 1, b:2}
DataSource.attribute_types
exit
DataSource
DataSource.attribute_names
source-method attribute_names
source-method DataSource.attribute_names
exit
ActionController::Base.without_modules(ActionController::HttpAuthentication::Digest::ControllerMethods)
ActionController::Base.without_modules(HttpAuthentication::Digest::ControllerMethods)
exit
require 'swagger'
require 'swagger_docs'
exit
User.last.to_json
exit
User.last.to_json
exit
User.last.to_json
Oj::Rails.deoptimize(Hash)
User.last.to_json
Report.last.to_json
exit
meta_data_source.attributes.slice(*%w(id))
meta_data_source.attributes.slice(%w(id))
meta_data_source.attributes.slice('id')
meta_data_source.attributes
    ))
      status
      active
      timezone
      nugit_types
      meta_data
      currency
      provider
      data_uid
      platform_uid
meta_data_source.attributes.slice(%w(
meta_data_source = MetaDataSource.last
    ))
      status
      active
      timezone
      nugit_types
      meta_data
      currency
      provider
      data_uid
      platform_uid
meta_data_source.attributes.slice(%w(
Time.now.to_f*1000
DataSource.last.attributes
exit
Tracer.display_c_call = true
require 'tracer'
Tracer.display_c_call = true
exit
DataSource.including_ignored_columns_subclass_name
exit
DataSource.including_ignored_columns.superclass.superclass.name
DataSource.including_ignored_columns.superclass.superclass
DataSource.including_ignored_columns.superclass
DataSource.including_ignored_columns.name
DataSource.including_ignored_columns.class.name
DataSource.including_ignored_columns.class
DataSource.including_ignored_columns
DataSource.last.created_at
DataSource.last[:created_at]
Team.last.data_sources.including_ignored_columns.where(group_id: nil).includes(:auth_token)
Team.last.data_sources.where(group_id: nil).includes(:auth_token).including_ignored_columns
Team.last.data_sources.where(group_id: nil).includes(:auth_token)
AuthToken.last.data_sources_with_file_specs_and_settings
reload!
AuthToken.last.data_sources.including_ignored_columns(:file_specs).each { |ds| puts ds.id }
AuthToken.last.data_sources.including_ignored_columns(:file_specs).last
AuthToken.last.data_sources.including_ignored_columns(:file_specs).all
AuthToken.last.data_sources.including_ignored_columns(:file_specs)
AuthToken.last.data_sources
ds = DataSource.including_ignored_columns.last
ds.including_ignored_columns
ds = DataSource.last
ds = DataSource.alst
exit
ds = DataSource.last
exit
AccessGroup.last.data_sources
AccessGroup.last.data_source_with_all
AccessGroup.last.data_sources_with_all
reload!
AccessGroup.last.data_sources_with_all
AccessGroup.last.data_sources
exit
Object.const_set('Aaaa', Class.new(ActiveRecord::Base))
Object.const_set('aaaa', Class.new(ActiveRecord::Base))
Class.new(ActiveRecord::Base).name
Team.including_ignored_columns.last
Team.last
ds.ds_segments.last
ds.ds_segments_with_all.last
ds= DataSource.find(146036)
exit
ds.ds_segments_with_all.last
ds.ds_segments.last
ds= DataSource.find(146036)
exit
ds.ds_segments.last
DataSource.eager_load(:ds_segments).last.ds_segments.last
ds.eager_load(:ds_segments).ds_segments.last
ds.ds_segments.last
ds= DataSource.find(146036)
DataSource.find(146048).parent_source.id
DataSource.find(146048).parent_source.ds_segments.count(:all)
DataSource.find(146048).parent_source.ds_segments.count
DataSource.find(146048).parent_source
DataSource.find(146048).parents
DataSource.find(146048).parent
DataSource.find(146048).ds_segments.count(:all)
DataSource.find(146048).ds_segments.count
DataSource.where('parent_source_id IS NOT NULL').pluck(:id)
DataSource.where('parent_source_id IS NOT NULL')
Team.eager_load(:metas_with_all).last.metas_with_all
Team.eager_load(:metas_with_user).last.metas_with_all
Team.eager_load(:metas_with_user).last.metas_with_user
Team.eager_load(:metas).last.metas
Team.eager_load(:metas_with_user).last.metas
Team.eager_load(:metas_with_all).last.metas
Team.eager_load(:metas_with_all).last.meta
Team.eager_load(:metas_with_all).last
Team.eager_load(:metas).last
exit
Team.eager_load(:metas_with_user).last
Team.eager_load(:metas_with_all).last
Team.eager_load(:metas).last
Team.eager_load(:metas_with_all).last
Team.eager_load(:metas_with_all).last(3).each { |t| puts t.metas.inspect; puts "111" }
Team.eager_load(:metas_including_all).last(3).each { |t| puts t.metas.inspect; puts "111" }
Team.eager_load(:metas).last(3).each { |t| puts t.metas.inspect; puts "111" }
Team.eager_load(:metas).last(3).each { |t| puts t.metas.to_s; puts "111" }
Team.eager_load(:metas).last(3).each { |t| puts t.metas; puts "111" }
Team.eager_load(:metas).last(3).each { |t| puts t.metas }
Team.eager_load(:metas).last(3).each { |t| t.metas }
Team.includes(:metas).last(3).each { |t| t.metas }
Team.includes(:metas).last(3).each { |t| t.meta }
Team.includes(:metas).last.metas
Team.includes(:metas).last.meta
Team.includes(:meta).last.meta
Team.last.metas.first
Team.last.metas
exit
Team.last.metas
Team.last.meta = { some: 'data' }
Team.last.metas
Team.last.meta_data
exit
DataProvider.pluck(:id, :uid)
DataProvider.where(id: 24).first.update(enabled: false)
DataProvider.where(id: 23).first.update(enabled: false)
DataProvider.where(id: 23).update(enabled: false)
DataProvider.pluck(:id, :uid)
DataProvider.unscoped.update_all(enabled: true)
DataProvider.last
reload!
DataProvider.last
DataProvider
DataSource.column_names.include? 'file_state'
DataSource.has_column? :file_state
DataSource.last.has_attribute? :file_state
DataSource.has_attribute? :file_state
DataSource.file_state
DataSource.last.file_state
DataSource.respond_to? :file_state
DataSource.responds_to? :file_state
DataSource.respond_to? :file_state
DataSource.where('file_settings IS NOT NULL').last
r = DataSource.create(activated: true, client_status: 'enabled', status: 'active_month', data_uid: '123---123123', auth_token: AuthToken.last, uid: '123123', platform_uid: '123123')
r.errors
r = DataSource.create(activated: true, client_status: 'enabled', status: 'active_month', data_uid: '123---123123', auth_token: AuthToken.last)
DataSource.create(activated: true, client_status: 'enabled', status: 'active_month', data_uid: '123---123123', auth_token: AuthToken.last)
DataSource.create(activated: true, client_status: 'enabled', status: 'active_month', data_uid: '123---123', auth_token: AuthToken.last)
exit
MetaDataSource.last
DataSource.create(activated: true, client_status: 'enabled', status: 'active_month', data_uid: '123---123', auth_token: AuthToken.last)
MetaDataSource.last
DataSource.create(activated: true, client_status: 'enabled', status: 'active_month', auth_token: AuthToken.last)
DataSource.create(activated: true, client_status: 'enabled', status: 'active_month')
exit
h.slice!(:b)
h = {a:1,b:2}
h = {a:1.b:2}
DataSource.where('meta_data IS NULL').last.meta_data
DataSource.where('meta_data IS NOT NULL').last.meta_data
DataSource.where('meta_data NOT NULL').last.meta_data
MetaDataSource.last.data_uid
exit
200.is_a? Hash
200.is_a? Symbol
AccessGroup.where('id > ?', '10').explain
AccessGroup.where('id > ?', '10')
AccessGroup.where('id > ?', '100')
AccessGroup.where(
Team.find(1116).global_access_group.segments.last.data_sources.count()
Team.find(1116).global_access_group.segments.last.data_sources.count(:all)
Team.find(1116).global_access_group.segments.last.data_sources.count
Team.find(1116).global_access_group.segments.last.data_sources_with_all.count
exit
s = Segment.all; nil
s = Segment.all
Segment.all.instance_variable_get('@values')[:select].object_id
Segment.all.instance_variable_get('@values')[:select]
